// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains instructions and instruction parsers.

package associatedtokenaccount

import (
	"fmt"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Builds a "create" instruction.
func NewCreateInstruction(
	payerAccount solanago.PublicKey,
	associatedTokenAccount solanago.PublicKey,
	walletAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 1 "associatedToken": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(associatedTokenAccount, true, false))
		// Account 2 "wallet": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(walletAccount, false, false))
		// Account 3 "mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, false, false))
		// Account 4 "systemProgram": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 5 "tokenProgram": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		[]byte{},
	), nil
}

// Builds a "createIdempotent" instruction.
func NewCreateIdempotentInstruction(
	payerAccount solanago.PublicKey,
	associatedTokenAccount solanago.PublicKey,
	walletAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 1 "associatedToken": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(associatedTokenAccount, true, false))
		// Account 2 "wallet": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(walletAccount, false, false))
		// Account 3 "mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, false, false))
		// Account 4 "systemProgram": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 5 "tokenProgram": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		[]byte{Instruction_CreateIdempotent[0]},
	), nil
}

// Builds a "recoverNested" instruction.
func NewRecoverNestedInstruction(
	nestedAssociatedTokenAccount solanago.PublicKey,
	nestedMintAccount solanago.PublicKey,
	destinationAssociatedTokenAccount solanago.PublicKey,
	ownerAssociatedTokenAccount solanago.PublicKey,
	ownerMintAccount solanago.PublicKey,
	ownerWalletAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "nestedAssociatedToken": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(nestedAssociatedTokenAccount, true, false))
		// Account 1 "nestedMint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(nestedMintAccount, false, false))
		// Account 2 "destinationAssociatedToken": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(destinationAssociatedTokenAccount, true, false))
		// Account 3 "ownerAssociatedToken": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(ownerAssociatedTokenAccount, false, false))
		// Account 4 "ownerMint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(ownerMintAccount, false, false))
		// Account 5 "ownerWallet": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(ownerWalletAccount, true, true))
		// Account 6 "tokenProgram": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		[]byte{Instruction_RecoverNested[0]},
	), nil
}

type CreateInstruction struct {

	// Accounts:
	Payer                   solanago.PublicKey `json:"payer"`
	PayerWritable           bool               `json:"payer_writable"`
	PayerSigner             bool               `json:"payer_signer"`
	AssociatedToken         solanago.PublicKey `json:"associatedToken"`
	AssociatedTokenWritable bool               `json:"associatedToken_writable"`
	Wallet                  solanago.PublicKey `json:"wallet"`
	Mint                    solanago.PublicKey `json:"mint"`
	SystemProgram           solanago.PublicKey `json:"systemProgram"`
	TokenProgram            solanago.PublicKey `json:"tokenProgram"`
}

func (obj *CreateInstruction) GetDiscriminator() []byte {
	return Instruction_Create[:]
}

// UnmarshalWithDecoder unmarshals the CreateInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *CreateInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	// Legacy ATA create is encoded with empty data.
	if decoder.Remaining() == 0 {
		return nil
	}
	if decoder.Remaining() != 1 {
		return fmt.Errorf("invalid instruction length for %s: expected 0 or 1 bytes, got %d", "CreateInstruction", decoder.Remaining())
	}
	discriminator, err := decoder.ReadUint8()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "CreateInstruction", err)
	}
	if discriminator != Instruction_Create[0] {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %d, got %d", "CreateInstruction", Instruction_Create[0], discriminator)
	}
	return nil
}

func (obj *CreateInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from payer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "payer", err)
	}
	indices = append(indices, index)
	// Decode from associatedToken account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "associatedToken", err)
	}
	indices = append(indices, index)
	// Decode from wallet account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "wallet", err)
	}
	indices = append(indices, index)
	// Decode from mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "mint", err)
	}
	indices = append(indices, index)
	// Decode from systemProgram account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "systemProgram", err)
	}
	indices = append(indices, index)
	// Decode from tokenProgram account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenProgram", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *CreateInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 6 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 6, len(indices))
	}
	indexOffset := 0
	// Set payer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "payer", len(accountKeys)-1)
	}
	obj.Payer = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set associatedToken account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "associatedToken", len(accountKeys)-1)
	}
	obj.AssociatedToken = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set wallet account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "wallet", len(accountKeys)-1)
	}
	obj.Wallet = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "mint", len(accountKeys)-1)
	}
	obj.Mint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set systemProgram account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "systemProgram", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenProgram account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenProgram", len(accountKeys)-1)
	}
	obj.TokenProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *CreateInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Payer)
	keys = append(keys, obj.AssociatedToken)
	keys = append(keys, obj.Wallet)
	keys = append(keys, obj.Mint)
	keys = append(keys, obj.SystemProgram)
	keys = append(keys, obj.TokenProgram)
	return keys
}

// Unmarshal unmarshals the CreateInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *CreateInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling CreateInstruction: %w", err)
	}
	return nil
}

// UnmarshalCreateInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalCreateInstruction(buf []byte) (*CreateInstruction, error) {
	obj := new(CreateInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type CreateIdempotentInstruction struct {

	// Accounts:
	Payer                   solanago.PublicKey `json:"payer"`
	PayerWritable           bool               `json:"payer_writable"`
	PayerSigner             bool               `json:"payer_signer"`
	AssociatedToken         solanago.PublicKey `json:"associatedToken"`
	AssociatedTokenWritable bool               `json:"associatedToken_writable"`
	Wallet                  solanago.PublicKey `json:"wallet"`
	Mint                    solanago.PublicKey `json:"mint"`
	SystemProgram           solanago.PublicKey `json:"systemProgram"`
	TokenProgram            solanago.PublicKey `json:"tokenProgram"`
}

func (obj *CreateIdempotentInstruction) GetDiscriminator() []byte {
	return Instruction_CreateIdempotent[:]
}

// UnmarshalWithDecoder unmarshals the CreateIdempotentInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *CreateIdempotentInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	// Read the discriminator and check it against the expected value:
	if decoder.Remaining() != 1 {
		return fmt.Errorf("invalid instruction length for %s: expected 1 byte, got %d", "CreateIdempotentInstruction", decoder.Remaining())
	}
	discriminator, err := decoder.ReadUint8()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "CreateIdempotentInstruction", err)
	}
	if discriminator != Instruction_CreateIdempotent[0] {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %d, got %d", "CreateIdempotentInstruction", Instruction_CreateIdempotent[0], discriminator)
	}
	return nil
}

func (obj *CreateIdempotentInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from payer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "payer", err)
	}
	indices = append(indices, index)
	// Decode from associatedToken account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "associatedToken", err)
	}
	indices = append(indices, index)
	// Decode from wallet account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "wallet", err)
	}
	indices = append(indices, index)
	// Decode from mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "mint", err)
	}
	indices = append(indices, index)
	// Decode from systemProgram account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "systemProgram", err)
	}
	indices = append(indices, index)
	// Decode from tokenProgram account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenProgram", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *CreateIdempotentInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 6 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 6, len(indices))
	}
	indexOffset := 0
	// Set payer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "payer", len(accountKeys)-1)
	}
	obj.Payer = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set associatedToken account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "associatedToken", len(accountKeys)-1)
	}
	obj.AssociatedToken = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set wallet account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "wallet", len(accountKeys)-1)
	}
	obj.Wallet = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "mint", len(accountKeys)-1)
	}
	obj.Mint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set systemProgram account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "systemProgram", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenProgram account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenProgram", len(accountKeys)-1)
	}
	obj.TokenProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *CreateIdempotentInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Payer)
	keys = append(keys, obj.AssociatedToken)
	keys = append(keys, obj.Wallet)
	keys = append(keys, obj.Mint)
	keys = append(keys, obj.SystemProgram)
	keys = append(keys, obj.TokenProgram)
	return keys
}

// Unmarshal unmarshals the CreateIdempotentInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *CreateIdempotentInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling CreateIdempotentInstruction: %w", err)
	}
	return nil
}

// UnmarshalCreateIdempotentInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalCreateIdempotentInstruction(buf []byte) (*CreateIdempotentInstruction, error) {
	obj := new(CreateIdempotentInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type RecoverNestedInstruction struct {

	// Accounts:
	NestedAssociatedToken              solanago.PublicKey `json:"nestedAssociatedToken"`
	NestedAssociatedTokenWritable      bool               `json:"nestedAssociatedToken_writable"`
	NestedMint                         solanago.PublicKey `json:"nestedMint"`
	DestinationAssociatedToken         solanago.PublicKey `json:"destinationAssociatedToken"`
	DestinationAssociatedTokenWritable bool               `json:"destinationAssociatedToken_writable"`
	OwnerAssociatedToken               solanago.PublicKey `json:"ownerAssociatedToken"`
	OwnerMint                          solanago.PublicKey `json:"ownerMint"`
	OwnerWallet                        solanago.PublicKey `json:"ownerWallet"`
	OwnerWalletWritable                bool               `json:"ownerWallet_writable"`
	OwnerWalletSigner                  bool               `json:"ownerWallet_signer"`
	TokenProgram                       solanago.PublicKey `json:"tokenProgram"`
}

func (obj *RecoverNestedInstruction) GetDiscriminator() []byte {
	return Instruction_RecoverNested[:]
}

// UnmarshalWithDecoder unmarshals the RecoverNestedInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *RecoverNestedInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	// Read the discriminator and check it against the expected value:
	if decoder.Remaining() != 1 {
		return fmt.Errorf("invalid instruction length for %s: expected 1 byte, got %d", "RecoverNestedInstruction", decoder.Remaining())
	}
	discriminator, err := decoder.ReadUint8()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "RecoverNestedInstruction", err)
	}
	if discriminator != Instruction_RecoverNested[0] {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %d, got %d", "RecoverNestedInstruction", Instruction_RecoverNested[0], discriminator)
	}
	return nil
}

func (obj *RecoverNestedInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from nestedAssociatedToken account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "nestedAssociatedToken", err)
	}
	indices = append(indices, index)
	// Decode from nestedMint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "nestedMint", err)
	}
	indices = append(indices, index)
	// Decode from destinationAssociatedToken account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "destinationAssociatedToken", err)
	}
	indices = append(indices, index)
	// Decode from ownerAssociatedToken account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "ownerAssociatedToken", err)
	}
	indices = append(indices, index)
	// Decode from ownerMint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "ownerMint", err)
	}
	indices = append(indices, index)
	// Decode from ownerWallet account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "ownerWallet", err)
	}
	indices = append(indices, index)
	// Decode from tokenProgram account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenProgram", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *RecoverNestedInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 7 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 7, len(indices))
	}
	indexOffset := 0
	// Set nestedAssociatedToken account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "nestedAssociatedToken", len(accountKeys)-1)
	}
	obj.NestedAssociatedToken = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set nestedMint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "nestedMint", len(accountKeys)-1)
	}
	obj.NestedMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set destinationAssociatedToken account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "destinationAssociatedToken", len(accountKeys)-1)
	}
	obj.DestinationAssociatedToken = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set ownerAssociatedToken account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "ownerAssociatedToken", len(accountKeys)-1)
	}
	obj.OwnerAssociatedToken = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set ownerMint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "ownerMint", len(accountKeys)-1)
	}
	obj.OwnerMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set ownerWallet account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "ownerWallet", len(accountKeys)-1)
	}
	obj.OwnerWallet = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenProgram account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenProgram", len(accountKeys)-1)
	}
	obj.TokenProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *RecoverNestedInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.NestedAssociatedToken)
	keys = append(keys, obj.NestedMint)
	keys = append(keys, obj.DestinationAssociatedToken)
	keys = append(keys, obj.OwnerAssociatedToken)
	keys = append(keys, obj.OwnerMint)
	keys = append(keys, obj.OwnerWallet)
	keys = append(keys, obj.TokenProgram)
	return keys
}

// Unmarshal unmarshals the RecoverNestedInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *RecoverNestedInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling RecoverNestedInstruction: %w", err)
	}
	return nil
}

// UnmarshalRecoverNestedInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalRecoverNestedInstruction(buf []byte) (*RecoverNestedInstruction, error) {
	obj := new(RecoverNestedInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Instruction interface defines common methods for all instruction types
type Instruction interface {
	GetDiscriminator() []byte

	UnmarshalWithDecoder(decoder *binary.Decoder) error

	UnmarshalAccountIndices(buf []byte) ([]uint8, error)

	PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error

	GetAccountKeys() []solanago.PublicKey
}

// ParseInstruction parses instruction data and optionally populates accounts
// If accountIndicesData is nil or empty, accounts will not be populated
func ParseInstruction(instructionData []byte, accountIndicesData []byte, accountKeys []solanago.PublicKey) (Instruction, error) {
	discriminator, err := IdentifyInstructionType(instructionData)
	if err != nil {
		return nil, err
	}
	// Parse based on discriminator
	switch discriminator {
	case Instruction_Create[0]:
		instruction := new(CreateInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as CreateInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_CreateIdempotent[0]:
		instruction := new(CreateIdempotentInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as CreateIdempotentInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_RecoverNested[0]:
		instruction := new(RecoverNestedInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as RecoverNestedInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	default:
		return nil, fmt.Errorf("unknown instruction discriminator: %d", discriminator)
	}
}

// ParseInstructionTyped parses instruction data and returns a specific instruction type // T must implement the Instruction interface
func ParseInstructionTyped[T Instruction](instructionData []byte, accountIndicesData []byte, accountKeys []solanago.PublicKey) (T, error) {
	instruction, err := ParseInstruction(instructionData, accountIndicesData, accountKeys)
	if err != nil {
		return *new(T), err
	}
	typed, ok := instruction.(T)
	if !ok {
		return *new(T), fmt.Errorf("instruction is not of expected type")
	}
	return typed, nil
}

// ParseInstructionWithoutAccounts parses instruction data without account information
func ParseInstructionWithoutAccounts(instructionData []byte) (Instruction, error) {
	return ParseInstruction(instructionData, nil, []solanago.PublicKey{})
}

// ParseInstructionWithAccounts parses instruction data with account information
func ParseInstructionWithAccounts(instructionData []byte, accountIndicesData []byte, accountKeys []solanago.PublicKey) (Instruction, error) {
	return ParseInstruction(instructionData, accountIndicesData, accountKeys)
}

func IdentifyInstructionType(data []byte) (uint8, error) {
	// Legacy `create` has empty data.
	if len(data) == 0 {
		return Instruction_Create[0], nil
	}
	if len(data) != 1 {
		return 0, fmt.Errorf("invalid instruction length: expected 0 or 1 bytes, got %d", len(data))
	}
	switch data[0] {
	case Instruction_Create[0], Instruction_CreateIdempotent[0], Instruction_RecoverNested[0]:
		return data[0], nil
	default:
		return 0, fmt.Errorf("unknown instruction discriminator: %d", data[0])
	}
}

func DecodeInstruction(accounts []*solanago.AccountMeta, data []byte) (Instruction, error) {
	inst, err := ParseInstructionWithoutAccounts(data)
	if err != nil {
		return nil, err
	}
	switch v := inst.(type) {
	case *CreateInstruction:
		if len(accounts) < 6 {
			return nil, fmt.Errorf("insufficient accounts for create: expected at least 6, got %d", len(accounts))
		}
		v.Payer = accounts[0].PublicKey
		v.PayerWritable = accounts[0].IsWritable
		v.PayerSigner = accounts[0].IsSigner
		v.AssociatedToken = accounts[1].PublicKey
		v.AssociatedTokenWritable = accounts[1].IsWritable
		v.Wallet = accounts[2].PublicKey
		v.Mint = accounts[3].PublicKey
		v.SystemProgram = accounts[4].PublicKey
		v.TokenProgram = accounts[5].PublicKey
	case *CreateIdempotentInstruction:
		if len(accounts) < 6 {
			return nil, fmt.Errorf("insufficient accounts for createIdempotent: expected at least 6, got %d", len(accounts))
		}
		v.Payer = accounts[0].PublicKey
		v.PayerWritable = accounts[0].IsWritable
		v.PayerSigner = accounts[0].IsSigner
		v.AssociatedToken = accounts[1].PublicKey
		v.AssociatedTokenWritable = accounts[1].IsWritable
		v.Wallet = accounts[2].PublicKey
		v.Mint = accounts[3].PublicKey
		v.SystemProgram = accounts[4].PublicKey
		v.TokenProgram = accounts[5].PublicKey
	case *RecoverNestedInstruction:
		if len(accounts) < 7 {
			return nil, fmt.Errorf("insufficient accounts for recoverNested: expected at least 7, got %d", len(accounts))
		}
		v.NestedAssociatedToken = accounts[0].PublicKey
		v.NestedAssociatedTokenWritable = accounts[0].IsWritable
		v.NestedMint = accounts[1].PublicKey
		v.DestinationAssociatedToken = accounts[2].PublicKey
		v.DestinationAssociatedTokenWritable = accounts[2].IsWritable
		v.OwnerAssociatedToken = accounts[3].PublicKey
		v.OwnerMint = accounts[4].PublicKey
		v.OwnerWallet = accounts[5].PublicKey
		v.OwnerWalletWritable = accounts[5].IsWritable
		v.OwnerWalletSigner = accounts[5].IsSigner
		v.TokenProgram = accounts[6].PublicKey
	default:
		return nil, fmt.Errorf("unsupported decoded instruction type %T", inst)
	}
	return inst, nil
}

func registryDecodeInstruction(accounts []*solanago.AccountMeta, data []byte) (interface{}, error) {
	return DecodeInstruction(accounts, data)
}
